-- =============================================
-- NOTIFICATION SYSTEM MIGRATION
-- Creates complete notification system tables and functions
-- =============================================

-- Create notifications table
CREATE TABLE IF NOT EXISTS public.user_notifications (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  type text NOT NULL,
  title text NOT NULL,
  message text NOT NULL,
  data jsonb DEFAULT '{}',
  read boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  read_at timestamp with time zone,
  CONSTRAINT user_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_notifications_user_id ON public.user_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_user_notifications_read ON public.user_notifications(read);
CREATE INDEX IF NOT EXISTS idx_user_notifications_type ON public.user_notifications(type);
CREATE INDEX IF NOT EXISTS idx_user_notifications_created_at ON public.user_notifications(created_at DESC);

-- Function to create user notifications
CREATE OR REPLACE FUNCTION create_user_notification(
  p_user_id uuid,
  p_type text,
  p_title text,
  p_message text,
  p_data jsonb DEFAULT '{}'
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  notification_id uuid;
BEGIN
  -- Validate user exists
  IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = p_user_id) THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;

  -- Insert notification
  INSERT INTO user_notifications (user_id, type, title, message, data)
  VALUES (p_user_id, p_type, p_title, p_message, p_data)
  RETURNING id INTO notification_id;

  RETURN notification_id;
END;
$$;

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION mark_notification_read(
  p_notification_id uuid,
  p_user_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE user_notifications 
  SET 
    read = true,
    read_at = now()
  WHERE id = p_notification_id 
    AND user_id = p_user_id 
    AND read = false;
  
  RETURN FOUND;
END;
$$;

-- Function to mark all notifications as read for a user
CREATE OR REPLACE FUNCTION mark_all_notifications_read(
  p_user_id uuid
)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  affected_count integer;
BEGIN
  UPDATE user_notifications 
  SET 
    read = true,
    read_at = now()
  WHERE user_id = p_user_id 
    AND read = false;
  
  GET DIAGNOSTICS affected_count = ROW_COUNT;
  
  RETURN affected_count;
END;
$$;

-- Function to get unread notification count
CREATE OR REPLACE FUNCTION get_unread_notification_count(
  p_user_id uuid
)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  unread_count integer;
BEGIN
  SELECT COUNT(*) INTO unread_count
  FROM user_notifications
  WHERE user_id = p_user_id AND read = false;
  
  RETURN unread_count;
END;
$$;

-- Function to clean old notifications (older than 90 days)
CREATE OR REPLACE FUNCTION cleanup_old_notifications()
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  deleted_count integer;
BEGIN
  DELETE FROM user_notifications
  WHERE created_at < (now() - interval '90 days');
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  RETURN deleted_count;
END;
$$;

-- =============================================
-- ROW LEVEL SECURITY
-- =============================================

-- Enable RLS on user_notifications
ALTER TABLE user_notifications ENABLE ROW LEVEL SECURITY;

-- Allow users to read their own notifications
CREATE POLICY "Users can read their own notifications" 
ON user_notifications 
FOR SELECT 
USING (user_id = auth.uid());

-- Allow system to create notifications
CREATE POLICY "System can create notifications" 
ON user_notifications 
FOR INSERT 
WITH CHECK (true);

-- Allow users to update their own notifications (mark as read)
CREATE POLICY "Users can update their own notifications" 
ON user_notifications 
FOR UPDATE 
USING (user_id = auth.uid()) 
WITH CHECK (user_id = auth.uid());

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION create_user_notification TO authenticated;
GRANT EXECUTE ON FUNCTION mark_notification_read TO authenticated;
GRANT EXECUTE ON FUNCTION mark_all_notifications_read TO authenticated;
GRANT EXECUTE ON FUNCTION get_unread_notification_count TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_old_notifications TO authenticated;

-- Grant table permissions
GRANT SELECT, UPDATE ON TABLE user_notifications TO authenticated;
GRANT INSERT ON TABLE user_notifications TO service_role;

-- =============================================
-- ADD COMMENTS
-- =============================================

COMMENT ON TABLE user_notifications IS 'System notifications sent to users';
COMMENT ON COLUMN user_notifications.user_id IS 'ID of the user receiving the notification';
COMMENT ON COLUMN user_notifications.type IS 'Type/category of the notification';
COMMENT ON COLUMN user_notifications.title IS 'Notification title';
COMMENT ON COLUMN user_notifications.message IS 'Notification message content';
COMMENT ON COLUMN user_notifications.data IS 'Additional JSON data for the notification';
COMMENT ON COLUMN user_notifications.read IS 'Whether the notification has been read';
COMMENT ON COLUMN user_notifications.read_at IS 'When the notification was marked as read';

COMMENT ON FUNCTION create_user_notification(uuid, text, text, text, jsonb) IS 'Creates a new user notification';
COMMENT ON FUNCTION mark_notification_read(uuid, uuid) IS 'Marks a specific notification as read';
COMMENT ON FUNCTION mark_all_notifications_read(uuid) IS 'Marks all notifications as read for a user';
COMMENT ON FUNCTION get_unread_notification_count(uuid) IS 'Gets the count of unread notifications for a user';
COMMENT ON FUNCTION cleanup_old_notifications() IS 'Removes notifications older than 90 days';
